

                ;******************************************************************************
                ;
                ;  
                ;  PC2Adv - Transfer disk image from PC to a NortStar Advantage using
                ;           a SIO board in port 1 or 2. 
                ;
                ;       This program is a PC2Flop-like program. It borrows much of the 
                ;       ideas and the code of these programs written by Mikle Douglas. 
                ;       His PC2Flop programs normally run without an OS but PC2Adv uses 
                ;       CP/M for writing the disk data and the console IO.
                ;
                ;       - write raw data of double sided doubble density disk in drive A or B
                ;         (512 bytes per sector, 10 sectors per track, 70 tracks). 
                ;       - use SIO board in port 1 or port 2 for the transfer of a disk image 
                ;         using the XMODEM protocol. The disk image is the linear sequence 
                ;         of the 512 byte sectors from track 0, sector 0 through 
                ;         track 69, sector 9
                ;
                ;	This program only runs under CP/M.
                ;
                ;	Written by Holger Linning
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	01/16/20    Original 
                ;
                ;  based on:
                ;
                ;
                ;  PC2Flop - Transfer disk image from PC to floppy over serial port
                ;	     using the IMSAI SIO-2 serial board and the North Star
                ;	     single density floppy controller.
                ;
                ;	This program writes a North Star single density disk from a disk image
                ;       transmitted from a PC. The image is transmitted through a serial port
                ;       using the XMODEM checksum protocol. The image is written directly to
                ; 	the floppy in raw format (256 bytes per sector, 10 sectors per track,
                ;	35 tracks). The disk image is the linear sequence of 256 byte sectors
                ;	from track 0, sector 0 through track 34 sector 9.
                ;
                ;	This program runs standalone at 0x100 or under CP/M.
                ;
                ;	Written by Mike Douglas
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	09/22/19    Original
                ;
                ;*****************************************************************************
                
                
 FFFF =         TRUE    equ     0ffffh          ;define value of true 
 0000 =         FALSE   equ     NOT TRUE        ;define value of false 
                
                ;*****************************************************************************
                ;
                ;  Switch for running under Advantage emulator ADE or not 
                ;   
                ;     see: North Star Advantage Z80 Computer Emulator (ADE) 
                ;          Jack Strangio
                ;          http://www.itelsoft.com.au/north_star_advantage_emulator.html
                ;
                ;  The emulator can be used for testing and debugging this program. If
                ;  runnuing under ADE set the directive to TRUE.
                ;
                ;*****************************************************************************
                
 0000 =         ADE     equ     FALSE           ;TRUE = ADE, FALSE = real Machine
                
                
                ;*****************************************************************************
                ; Disk information equates
                
 0046 =         NUMTRK	equ	70		;number of tracks
 0028 =         NUMSEC	equ	40		;number of sectors per track (logical CPM sectors)
 0080 =         SECLEN	equ	128		;sector length (logical CPM sectors)
 0000 =         MINDRV	equ	0		;first drive number
 0001 =         MAXDRV	equ	1		;max drive number 
                
 1400 =         TRKLEN	equ	(NUMSEC*SECLEN)	;length of track in bytes
                
                ; CP/M start addresses
 0001 =         BIOSPTR equ     0000h+1         ;pointer to BIOS 
 0006 =         BDOSPTR equ     0005h+1         ;pointer to BDOS         
                
                ; BIOS jump table entry points
 0000 =         BOOT	equ     00h             ;Cold start 
 0003 =         WBOOT	equ     BOOT+3          ;Warm boot
 0006 =         CONST	equ     BOOT+6          ;Console status
 0009 =         CONIN	equ     BOOT+9          ;Console input
 000C =         CONOUT	equ     BOOT+12         ;Console output
 000F =         LIST	equ     BOOT+15         ;Printer output
 0012 =         PUNCH	equ     BOOT+18         ;Paper tape punch output
 0015 =         READER	equ     BOOT+21         ;Paper tape reader input
 0018 =         HOME	equ     BOOT+24         ;Move disc head to track 0
 001B =         SELDSK	equ     BOOT+27         ;Select disc drive
 001E =         SETTRK	equ     BOOT+30         ;Set track number
 0021 =         SETSEC	equ     BOOT+33         ;Set sector number
 0024 =         SETDMA	equ     BOOT+36         ;Set DMA address
 0027 =         READ	equ     BOOT+39         ;Read a sector
 002A =         WRITE	equ     BOOT+42         ;Write a sector
                
                ; XMODEM equates
                        IF      NOT ADE
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
                        ENDIF
                
                        IF      ADE
                DUMMY   equ     0ffh
                SOH	equ	DUMMY           ;use dummy values for XMODEM            
                EOT	equ	DUMMY           
                ACK	equ	DUMMY
                NAK	equ	DUMMY
                        ENDIF
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 000A =         XMTRIES	equ	10		;number of xmodem retries
                
                ; character equates
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7Fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
                
 0100           	org	0100h	
                ;-----------------------------------------------------------------------------
                ;  Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 31E408    init	lxi	sp,ourStk	;initialize stack pointer
                
 0103 2A0100            lhld    BIOSPTR
 0106 2B                dcx     h
 0107 2B                dcx     h
 0108 2B                dcx     h
 0109 22E006            shld    biosStart       ;save start of BIOS
                
 010C CD2F03    	call	setDrvN		;set drive names 
 010F CD3F03    	call	sizeRam		;determine amount of RAM available
 0112 3E00      	mvi	a,MINDRV	;a=default drive
 0114 32CF06    	sta	drvNum		;need for pgmExit
                
                        IF      ADE
                        lxi     h,0000h
                        shld    helpVal         ;init help var for debugging
                        ENDIF
                
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0117 217003    	lxi	h,mWelcom	;display welcome message
 011A CD8E02    	call	dispMsg
                
                ; getDrv - get drive letter from the user.
                
 011D 211F04    getDrv	lxi	h,mDrive	;display drive number prompt
 0120 CD8E02    	call	dispMsg
 0123 CDA302    	call	rcvCon		;get byte from the console
 0126 F620      	ori	20h		;upper case letters to lower case
 0128 FE78      	cpi	'x'		;exit requested?
 012A CA0F03    	jz	pgmExit		;yes
 012D 21E206    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 0130 96        	sub	m
 0131 FA1D01    	jm	getDrv		;error, entry was < first drive
 0134 FE02      	cpi	MAXDRV-MINDRV+1	;validate <= max drive
 0136 D21D01    	jnc	getDrv		;invalid, prompt again
 0139 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 013B 32CF06    	sta	drvNum		;save the drive number to use
                
                ; Verify drive is not write protected
                
 013E CD2D06    	call	dRestor		;restore to track 0 (selects drive)
                
                ; getPort - get serial port number 1-2 from the user.
                
 0141 215C04    getPort	lxi	h,mPort		;display transfer port prompt
 0144 CD8E02    	call	dispMsg
 0147 CDA302    	call	rcvCon		;get byte from the console
 014A F620      	ori	20h		;upper to lower case, nums not affected
 014C FE78      	cpi	'x'		;exit requested?
 014E CA0F03    	jz	pgmExit		;yes
 0151 D631      	sui	'1'		;'1' to 0
 0153 FE02      	cpi	2		;validate input was '1' or '2'
 0155 D24101    	jnc	getPort		;invalid, prompt again
 0158 32DA06    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to insert the disk to write, initialize, then start
                ;   sending NAK to start the XMODEM reception.
                
 015B 21B504    	lxi	h,mStart	;display start file transfer prompt
 015E CD8E02    	call	dispMsg
                        
 0161 AF        	xra	a		;init track counter
 0162 32D006    	sta	curTrk          ;start with track 0
                	
 0165 3C                inr	a		;init xmodem block number to one
 0166 32DB06    	sta	blkNum
                
 0169 3E15      	mvi	a,NAK		;send starting nak after purging input data
 016B CDD102    	call	purgSio         
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Receive as many packets as will fit into RAM and then write
                ;      tracks to disk. Repeat until entire disk is written. 
                ;-----------------------------------------------------------------------------
 016E 213E05    mainLp	lxi	h,mRecv		;display "Receiving"	
 0171 CD8E02    	call	dispMsg
                        
 0174 CDF505            call    initBf          ;init buffering 
                        
 0177 CDCA01            call	bufPkts		;buffer as many packets as possible
                
 017A 2ADE06    	lhld	rcvPtr		;hl=start of last packet received
 017D EB        	xchg			;de=start of last packet received
 017E 210010    	lxi	h,trkBuf	;hl=start of track buffer
 0181 CD6403    	call	cmpDeHl		;compare last packet start - trkBuf
 0184 DABC01    	jc	allDone		;nothing received but an EOT
                
 0187 217705            lxi	h,mWrite	;display "Writing"	
 018A CD8E02    	call	dispMsg
                
                ; trkLoop - write tracks until all disk tracks have been written or all
                ;    the tracks in the buffer have been written.
                
 018D CD6502    trkLoop	call	wrtTrak		;write a track
                
 0190 3AD306            lda     wrtTrk          ;increment written tracks in buffer 
 0193 3C        	inr	a
 0194 32D306    	sta	wrtTrk	
                
 0197 CD1306            call    setNTrk         ;set next track (return in a)
                
 019A FE46      	cpi	NUMTRK		;done all tracks?
 019C CABC01    	jz	allDone		;yes
                        
 019F CD9406    	call	getEndB		;hl=end of written tracks in buffer
 01A2 EB        	xchg			;de=next track pointer
 01A3 2ADE06    	lhld	rcvPtr		;hl=start of last packet received
 01A6 CD6403    	call	cmpDeHl		;compare end of buffer - rcvPtr
                
 01A9 DA8D01    	jc	trkLoop		;another track is present
                
 01AC 3AE306    	lda	eotFlag		;see if EOT terminated the reception
 01AF FE04      	cpi	EOT	
 01B1 CABC01    	jz	allDone		;if so, probably a single side disk
 01B4 3E06      	mvi	a,ACK		;ACK the last packet or EOT
 01B6 CDDB02    	call	sndByte
 01B9 C36E01    	jmp	mainLp		;go receive more packets
                
                ; allDone - The disk is completely written. ACK the final packet (or EOT),
                ;     display the "transfer complete" message and start the program over.
                
 01BC 3E06      allDone	mvi	a,ACK		;ACK the final packet or EOT
 01BE CDDB02    	call	sndByte
 01C1 21D104    	lxi	h,mDone		;hl->done message
 01C4 CD8E02    	call	dispMsg
 01C7 C31D01    	jmp	getDrv		;start over asking for drive num
                
                ;-----------------------------------------------------------------------------
                ; bufPkts - Receive XMODEM packets until we fill all the track buffer
                ;   space available. Reception starts at the address pointed to by
                ;   rcvPtr. Reception is stopped when the last packet exactly
                ;   fills the end of the last track spot in RAM. rcvPtr is
                ;   updated on exit to point to the start of the last packet received.
                ;   The disk write routines use this pointer to know where data ends and
                ;   then update rcvPtr to start to where to begin receiving new packets.
                ;-----------------------------------------------------------------------------
 01CA 2ADE06    bufPkts	lhld    rcvPtr
 01CD CDFA01            call	rcvPkt		;receive a packet (Pointer to buffer in HL) 
                
 01D0 E5                push    h
 01D1 CD9B02    	call    dispPgs         ;show progress
 01D4 E1                pop     h
                
 01D5 EB        	xchg			;de=current xmodem receive pointer
 01D6 32E306    	sta	eotFlag		;save status returned (may be EOT)
 01D9 FE04      	cpi	EOT		;EOT received?
 01DB CAF001    	jz	bufDone		;yes, buffering is done
 01DE 2AD606    	lhld	bufEnd		;hl=end of buffering space
 01E1 CD6403    	call	cmpDeHl		;compare current-end	
 01E4 D2F001    	jnc	bufDone		;past or at end, buffering is done
 01E7 3E06      	mvi	a,ACK		;otherwise, ACK the packet
 01E9 CDDB02    	call	sndByte
 01EC EB        	xchg			;put xmodem rcv pointer back in HL
 01ED C3CA01    	jmp	bufPkts		;buffer some more
                
                ; bufDone - no more room for packets. Update rcvPtr to point to the 
                ;   start of the last packet received so the disk write routines know
                ;   where data ends.
                
 01F0 22DE06    bufDone	shld	rcvPtr		;save use by write tracks
 01F3 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; rcvPkt - receive an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to receive. HL is updated by 128 bytes after each succuessful
                ;    reception of a new 128 byte packet.
                ;-----------------------------------------------------------------------------
                
 01F4 E1        nakPkt	pop	h		;get HL back
 01F5 3E15      	mvi	a,NAK
 01F7 CDD102    	call	purgSio		;purge receive for 1s then transmit NAK
                
                ;wait for SOH or EOT
                
                rcvPkt	
                        IF ADE                     ;fill buffer with dummy values
                        push    h               ;save pointer
                        lhld    helpVal;        ;load help value
                        inx     h               ;increment to produce new value
                        mov     a,l             ;use lower byte fo fill buffere
                        shld    helpVal         ;save new helpVal
                        pop     h               ;get pointer back
                        mvi     b,PKTLEN        
                dmmyLp  mov     m,a
                        inx     h
                        dcr     b    
                        jnz     dmmyLp
                        shld    rcvPtr          ;update pointer
                   	xra	a		   ;return a zero
                        ret
                        ENDIF
                        
 01FA E5                push	h		;save HL for retries
 01FB CDFC02    waitSoh	call	chkQuit		;check for user abort
 01FE 3E03      	mvi	a,3		;3 second timeout for soh
 0200 CDE202    	call	rcvByte		;receive character with timeout
 0203 CAF401    	jz	nakPkt		;timeout
 0206 FE01      	cpi	SOH		;SOH received?
 0208 CA1202    	jz	haveSoh
 020B FE04      	cpi	EOT		;EOT to say we're done?
 020D C2FB01    	jnz	waitSoh		;no, keep looking for SOH
 0210 E1        	pop	h		;undo the entry push
 0211 C9        	ret			;return with EOT
                
                ;  Have SOH, receive block number and not block number
                
 0212 3E01      haveSoh	mvi	a,1		;one second timeout once inside a packet
 0214 CDE202    	call	rcvByte		;get the block number
 0217 CAF401    	jz	nakPkt		;timeout, NAK and start over
 021A 32DC06    	sta	rcvBlk		;save the received block number
 021D 3E01      	mvi	a,1		;one second timeout
 021F CDE202    	call	rcvByte		;get not block number
 0222 CAF401    	jz	nakPkt		;timeout, NAK and start over
 0225 32DD06    	sta	rcvNBlk		;save not block number
                
                ;  Receive the 128 byte block
                
 0228 1E00      	mvi	e,0		;init checksum
 022A 1680      	mvi	d,pktLen	;d is byte counter
 022C 3E01      pktLoop	mvi	a,1		;one second timeout
 022E CDE202    	call	rcvByte		;get next data byte
 0231 CAF401    	jz	nakPkt		;timeout
 0234 77        	mov	m,a		;store the character
 0235 23        	inx	h		;point to next byte
 0236 83        	add	e		;update the checksum
 0237 5F        	mov	e,a
 0238 15        	dcr	d		;decrement bytes remaining
 0239 C22C02    	jnz	pktLoop
                
                ;  Verify the checksum
                
 023C 3E01      	mvi	a,1		;one second timeout
 023E CDE202    	call	rcvByte		;get the checksum
 0241 CAF401    	jz	nakPkt		;timeout
 0244 BB        	cmp	e		;checksum match?
 0245 C2F401    	jnz	nakPkt		;no, packet error
                
                ;  Checksum good. Verify block numbers
                
 0248 3ADD06    	lda	rcvNBlk		;verify rcvBlk = not (rcvNBlk)
 024B 2F        	cma			;A should = block number now
 024C 47        	mov	b,a		;save in b
 024D 3ADC06    	lda	rcvBlk
 0250 B8        	cmp	b		;compare rcvBlk = not(rcvNBlk)?
 0251 C2F401    	jnz	nakPkt		;no, error
 0254 3ADB06    	lda	blkNum		;compare rcvBlk = expected blkNum
 0257 B8        	cmp	b
 0258 C2F401    	jnz	nakPkt		;nak if not the same (also nak's re-send)
 025B 3C        	inr	a		;increment expected block number
 025C 32DB06    	sta	blkNum
 025F C1        	pop	b		;get HL off stack, but don't clobber HL
 0260 AF        	xra	a		;return a zero
 0261 22DE06            shld    rcvPtr          ;point to next block
 0264 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; wrtTrak - write NUMSEC sectors to the current track in trkBuf
                ;   as pointed to by trkPtr. After the track is written, trkPtr is updated
                ;   by the length of a track to point to the next track buffer. 
                ;-----------------------------------------------------------------------------
 0265 21B705    wrtTrak	lxi	h,mCRLF	        ;new line for next blocks	
 0268 CD8E02    	call	dispMsg
                
 026B CD0306            call    initT           ;init track writing 
 026E CD3A06            call	dSeek		;seek to the track
                
                ; wrtLoop - write a full track starting sector 0
                
 0271 CDFC02    wrtLoop	call	chkQuit		;check for ctrl-c
 0274 CD5A06            call	setSect		;set desired sector 
 0277 CD1B06    	call	dWrite		;write the sector
 027A CD9B02    	call    dispPgs         ;show progress
 027D CD5206            call	setNSec	        ;set next sector 
 0280 CD6606            call    setOffs         ;set new offset in buffer
 0283 3AD406            lda     wrtSec
 0286 3D                dcr     a
 0287 32D406            sta     wrtSec          ;decrement sectors to write
 028A C27102            jnz	wrtLoop		;loop until all sectors written
 028D C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers c, hl
                ;-----------------------------------------------------------------------------
 028E 7E        dispMsg	mov	a,m		;get the next message byte
 028F B7        	ora	a		;null terminates
 0290 C8        	rz
                        
 0291 4F        	mov	c,a		;CONOUT wants character in c
 0292 1E0C              mvi     e,CONOUT
 0294 CDE805    	call	BIOS
 0297 23        	inx	h		;move to next byte
 0298 C38E02    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; dispPgs - display progress
                ;    Clobbers c
                ;-----------------------------------------------------------------------------
 029B 0E2E      dispPgs	mvi	c,'.'		;CONOUT wants character in c
 029D 1E0C              mvi     e,CONOUT
 029F CDE805    	call	BIOS
 02A2 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers c.
                ;-----------------------------------------------------------------------------
 02A3 1E09      rcvCon	mvi     e,CONIN
 02A5 CDE805            call	BIOS		;check for input
                
 02A8 E67F      	ani	7fh
 02AA FE03      	cpi	CTRLC		;abort requested?
 02AC CA0F03    	jz	pgmExit		;yes
                
 02AF FE0D      	cpi	CR		;return pressed?
 02B1 C8        	rz			;yes, don't echo it
                
 02B2 4F        	mov	c,a		;CONOUT needs character in c
 02B3 1E0C              mvi     e,CONOUT
 02B5 CDE805    	call	BIOS            ;echo it
                
                ; Wait for CR, then return 1st character typed
 02B8 1E09      rcvCr	mvi     e,CONIN
 02BA CDE805            call	BIOS		;check for input
                
 02BD E67F      	ani	7fh
 02BF FE03      	cpi	CTRLC		;abort requested?
 02C1 CA0F03    	jz	pgmExit		;yes
                
 02C4 FE7F      	cpi	DEL		;delete
 02C6 C8        	rz			;yes, return DEL character
                
 02C7 FE08      	cpi	BS		;backspace?
 02C9 C8        	rz			;yes, return BS character
 02CA FE0D      	cpi	CR		;return pressed?
                
 02CC C2B802    	jnz	rcvCr		;no, keep waiting
 02CF 79        	mov	a,c		;return 1st character typed
 02D0 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; purgSio - Wait for 1 second of idle time on receive line, then transmit the
                ;	character passed in A (usually ACK or NAK). Clobbers b
                ;-----------------------------------------------------------------------------
 02D1 F5        purgSio	push	a
 02D2 3E01      purge	mvi	a,1		;1 second timeout
 02D4 CDE202    	call	rcvByte		;wait for 1 second without activity
                
                        IF NOT ADE              ;wait only on real machine
 02D7 C2D202    	jnz	purge
                        ENDIF
                
 02DA F1        	pop	a		;get back the character to send
                				;fall through to sndByte
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Clobbers b. (assuming serOut clobbers only a).
                ;-----------------------------------------------------------------------------
 02DB 47        sndByte	mov	b,a		;b=byte to transmit
 02DC 3ADA06    	lda	xfrPort		;a=port to use for transfer
 02DF C3CE05    	jmp	serOut		;send the character
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from the specified transfer port. A wait timeout
                ;     in seconds is specified in a. If a timeout occurs, zero is returned in
                ;     a and the zero flag is true. Otherwise, the character is returned in a 
                ;     (could be zero) and the zero flag is false. ONESEC must be set based on
                ;     processor speed and the number of cycles in the serIn call + 59.
                ;     Clobbers a, b and c.
                ;-----------------------------------------------------------------------------
 02E2 D5        rcvByte	push	d		;save d, e
 02E3 57        	mov	d,a		;save timeout in d
                
 02E4 01B49A    initSec	lxi	b,ONESEC	;bc=cycles through this loop for 1s
 02E7 3ADA06    rcvWait	lda	xfrPort		;(13) a=port to use for transfer
 02EA CDBA05    	call	serIn		;(17+42) look for a byte
 02ED C2FA02    	jnz	haveChr		;(10) byte received
 02F0 0B        	dcx	b		;(5) otherwise, decrement timer
 02F1 78        	mov	a,b		;(5) one second expire?
 02F2 B1        	ora	c		;(4)
 02F3 C2E702    	jnz	rcvWait		;(10) no, keep waiting
                
                ; one second timeout has occured. Decrement the seconds counter.
                
 02F6 15        	dcr	d		;decrement seconds counter
 02F7 C2E402    	jnz	initSec		;initialize for another 1 second count
 02FA D1        haveChr	pop	d		;restore d, e
 02FB C9        	ret
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 02FC 1E06      chkQuit	mvi     e,CONST
 02FE CDE805            call	BIOS		;check for console input
 0301 FE00              cpi     00h             ;0 = no character
 0303 C8        	rz
                        
 0304 E67F      	ani	7fh
 0306 FE03      	cpi	CTRLC		;abort requested?
 0308 C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 0309 31E408    	lxi	sp,ourStk	;initialize stack pointer
 030C C31D01    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M 
                ;--------------------------------------------------------------
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 030F 3ACF06    pgmExit	lda	drvNum		;boot drive used?
 0312 D600      	sui	MINDRV
 0314 C22003    	jnz	noDisk		;not 1, disk prompt not needed
                        
 0317 210705    	lxi	h,mCpm		;display "insert cp/m disk"	
 031A CD8E02    	call	dispMsg
 031D CDA302    	call	rcvCon		;wait for a character
                        
 0320 21F704    noDisk	lxi	h,mExit		;display "exiting" message
 0323 CD8E02    	call	dispMsg
                        
 0326 2AE006            lhld    biosStart
 0329 1600              mvi     d,00h
 032B 1E03              mvi     e,WBOOT
 032D 19                dad     d
 032E E9        	pchl		        ;reboot CP/M
                
                ;--------------------------------------------------------------
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                ;--------------------------------------------------------------
                
 032F 3E41      setDrvN	mvi	a,'A'		;'A' in drive message instead of number
 0331 324804    	sta	mDrvMin
 0334 C601      	adi	MAXDRV-MINDRV	;max drive letter
 0336 324A04    	sta	mDrvMax
 0339 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 033B 32E206    	sta	baseDrv
 033E C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
 033F 2A0600    sizeRam	lhld	BDOSPTR		;get address of BDOS
                
                ; ramEnd - end of RAM found. Now determine the end address + 1 of the
                ;   last track buffer that will fit in RAM. Store in bufEnd
                
 0342 EB        ramEnd	xchg			;de=end of RAM + 1
 0343 3EEB      	mvi	a,-((TRKLEN SHR 8) + 1) AND 0ffh
 0345 BA        	cmp	d		;force de < (10000h - TRKLEN)
 0346 D24A03    	jnc	topOk
 0349 57        	mov	d,a		;limit max address
 034A 210010    topOk	lxi	h,trkBuf	;hl=start of track buffer
 034D 010014    	lxi	b,TRKLEN	;bc=length of track in bytes
                
                ; Loop increasing hl by TRKLEN until hl > end of RAM.
                
 0350 09        bfEndLp	dad	b		;hl=hl+track length
 0351 CD5F03    	call	cmpHlDe		;compare hl-de
 0354 DA5003    	jc	bfEndLp		;still more room, keep going
                
                ; Subtrack one track length from hl, this will be the end address + 1 of
                ;   the the last track buffer that will fit in RAM
                
 0357 0100EC    	lxi	b,-TRKLEN	;subtract one track length
 035A 09        	dad	b		;hl = end address of last track + 1
 035B 22D606    	shld	bufEnd		;save as bufEnd
 035E C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 035F 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 0360 93        	sub	e
 0361 7C        	mov	a,h		;do msbs
 0362 9A        	sbb	d
 0363 C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 0364 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 0365 95        	sub	l
 0366 7A        	mov	a,d		;do msbs
 0367 9C        	sbb	h
 0368 C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subHlDe - HL=HL-DE
                ;--------------------------------------------------------------------
 0369 7D        subHlDe	mov	a,l		;subtract HL-DE, do lsbs first
 036A 93        	sub	e
 036B 6F        	mov	l,a		;lsb result in l
 036C 7C        	mov	a,h		;do msbs
 036D 9A        	sbb	d
 036E 67        	mov	h,a		;msb result in h	
 036F C9        	ret
                ;-----------------------------------------------------------------------------
                ;   Data Area
                ;-----------------------------------------------------------------------------
 0370 0D0A0A    mWelcom	db	cr,lf,lf
 0373 3D3D3D3D3D	db	'===== PC to Northstar Advantage Image Transfer v1.0 ====='
 03AC 0D0A0A    	db	cr,lf,lf	
 03AF 5468697320	db	'This program writes a North Star Advantage floppy from'
 03E5 0D0A      	db	cr,lf
 03E7 6120646973	db	'a disk image received through a serial port via XMODEM.',0
                
 041F 0D0A0A496EmDrive	db	cr,lf,lf,'Insert and specify destination drive ('
 0448 782D      mDrvMin	db	'x-'
 044A 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 045C 0D0A0A    mPort	db	cr,lf,lf
 045F 5370656369	db	'Specify the port of the SIO card to use for the image ',cr,lf
 0497 7472616E73	db	'transfer (1-2) or X to exit: ',0
                
 04B5 0D0A0A    mStart	db	cr,lf,lf
 04B8 5374617274	db	'Start XMODEM send now...',0
                
 04D1 0D0A0A4372mDone	db	cr,lf,lf,'Creation of new disk successful!',cr,lf,0
                
 04F7 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 0507 0D0A0A    mCpm	db	cr,lf,lf
 050A 496E736572	db	'Insert CP/M disk into drive A, then press Return...',0
                
 053E 0D0A0A    mRecv	db	cr,lf,lf
 0541 5265636569	db	'Receiving image data from PC (dot = XMODEM packet)',cr,lf,lf,0
                
 0577 0D0A0A    mWrite	db	cr,lf,lf
 057A 5772697469	db	'Writing buffer to floppy disk (line = track, dot = sector)',cr,lf,0
                
 05B7 0D0A00    mCRLF	db	cr,lf, 0
                
                ;****************************************************************************
                ;
                ;  Hardware specific console and serial I/O routines. 
                ;     The following four routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; 8251 UART Equates
                
 0051 =         SIOACR	equ	51h		;control, SIO Board in slot 1
 0050 =         SIOADR	equ	50h		;data, SIO Board in slot 1
                
 0041 =         SIOBCR	equ	41h		;control, SIO Board in slot 2
 0040 =         SIOBDR	equ	40h		;data, SIO Board in slot 2
                
 0002 =         SIORDA	equ	02h		;read data available flag
 0001 =         SIOTRE	equ	01h		;transmit register empty flag
                
 0008 =         SIOCTL	equ	08h		;interrupt control register
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 9AB4 =         ONESEC	equ	39604		;rcvByte loop count for 1 second (4mhz)
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = first serial port
                ;       1 = second serial port
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ; 42 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 05BA B7        serIn	ora	a		;(4) port 0 or 1?
 05BB C2C605    	jnz	s2InB		;(10) port 1, 2nd serial port
                
                ; Input from 1st serial port
                
 05BE DB51      s2InA	in	SIOACR		;(10+1) see if a new character is present
                        
                        IF      ADE
                        mvi     a,SIORDA        ;character always available if ADE
                        ENDIF
                	
 05C0 E602              ani	SIORDA		;(7)
 05C2 C8        	rz			;(10) no character, return zero status
 05C3 DB50      	in	SIOADR		;return character and non-zero status
                
                        IF      ADE
                        mvi     a,DUMMY         ;use just dummy character 
                        ENDIF
                
 05C5 C9        	ret	
                	
                ; Input from 2nd serial port
                
 05C6 DB41      s2InB	in	SIOBCR		;(10+1) see if a new character is present
                        
                        IF      ADE
                        mvi     a,SIORDA        ;character always available if ADE
                        ENDIF
                	
 05C8 E602      	ani	SIORDA		;(7)
 05CA C8        	rz			;(10) no character, return zero status
 05CB DB40      	in	SIOBDR		;return character and non-zero status
                
                        IF      ADE
                        mvi     a,DUMMY         ;use just dummy character 
                        ENDIF
                
 05CD C9        	ret		
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = console serial port
                ;       1 = second serial port
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;-----------------------------------------------------------------------------
 05CE B7        serOut	ora	a		;port 0 or 1 ?
 05CF C2DD05    	jnz	s2OutB		;second serial port
                
                ; Send character through console serial port
                
 05D2 DB51      S2OutA	in	SIOACR		;wait for OK to transmit
 05D4 E601      	ani	SIOTRE
 05D6 CAD205    	jz	S2OutA
 05D9 78        	mov	a,b		;a=character to transmit
 05DA D350      	out	SIOADR		;send it
 05DC C9        	ret
                
                ; Send character through second serial port
                
 05DD DB41      s2OutB	in	SIOBCR		;wait for OK to transmit
 05DF E601      	ani	SIOTRE
 05E1 CADD05    	jz	s2OutB
 05E4 78        	mov	a,b		;a=character to transmit
 05E5 D340      	out	SIOBDR		;send it
 05E7 C9        	ret
                
                ;****************************************************************************
                ;
                ; BIOS related routines
                ;
                ;****************************************************************************
                
                ;***Subroutine**************************************
                ;
                ; BIOS -  perform the BIOS calls based on parameter 
                ; in register E to make calls independent of memory 
                ; layout (CP/M Vers. 2.2 Rev A / CP/M Vers. 2.2 Rev 1.2.0) 
                ;
                ; input parameters for BIOS calls in A, C or BC
                ; output parameters for BIOS calls in A
                ; offset of BIOS function in E
                ; preserves HL
                ;
                ;***************************************************
                
 05E8 E5        BIOS    push    h               ;save HL
 05E9 CDEE05            call    jmpBIOS         ;call BIOS function
 05EC E1                pop     h               ;restore HL
 05ED C9                ret
                
 05EE 2AE006    jmpBIOS lhld    biosStart       ;start of BIOS in HL
 05F1 1600              mvi     d,00h
 05F3 19                dad     d               ;offset for BIOS call in E
 05F4 E9                pchl                    ;jump to BIOS routine
                
                ;***Subroutine**************************************
                ; initBf - init vars for buffer 
                ;***************************************************
                
 05F5 210010    initBf: lxi     h,trkBuf        ;buffer start
 05F8 22D106            shld    trkPtr          ;reset pointer
 05FB 22DE06            shld    rcvPtr
 05FE AF                xra	a
 05FF 32D306            sta     wrtTrk          ;init count of written tracks
 0602 C9                ret
                
                ;***Subroutine**************************************
                ; initT - init vars for writing track 
                ;***************************************************
                
 0603 AF        initT:  xra	a
 0604 32D506            sta     curSec          ;start at sector 0
 0607 3E28              mvi	a,NUMSEC	;init count of sectors to write
 0609 32D406            sta     wrtSec         
 060C CD9406            call    getEndB         ;get start of buffer in HL
 060F 22D106            shld    trkPtr          ;pointer to free buffer
 0612 C9                ret
                
                ;***Subroutine******************************
                ; setNTrk - set next track number
                ;*******************************************
                
 0613 3AD006    setNTrk:lda	curTrk	        ;current track accessed
 0616 3C                inr     a               ;move to next track 
 0617 32D006            sta     curTrk          ;new current track
 061A C9        	ret 			
                
                ;***Subroutine**************************************
                ; dWrite - Write sector on current track to buffer at prt.
                ;***************************************************
                
 061B 2AD106    dWrite: lhld    trkPtr          ;pointer in buffer
 061E 44                mov	b,h		;set dma address in BC
 061F 4D                mov	c,l		
 0620 1E24              mvi     e,SETDMA
 0622 CDE805            call    BIOS            ;set dma address
 0625 0E01              mvi     c,01h           ;write must be immediate 
 0627 1E2A              mvi     e,Write          
 0629 CDE805            call    BIOS            ;write track
 062C C9        	ret			
                        
                ;***Subroutine*************************
                ; dRestor - Restore to track 0
                ; On Exit:
                ;   curTrk = 0 
                ;**************************************
                
 062D CD4606    dRestor: call	setDrv		;select drive
 0630 AF                xra     a
 0631 32D006    	sta	curTrk		;current track = 0
 0634 1E18              mvi     e,HOME          
 0636 CDE805            call    BIOS            ;move head to track 0
 0639 C9        	ret			
                
                ;***Subroutine**************************************
                ; dSeek - set drive and track
                ;***************************************************
                
 063A 3AD006    dSeek:	lda	curTrk		;load track number
 063D 0600              mvi	b,00h		;set track number in BC
 063F 4F                mov	c,a		
 0640 1E1E              mvi     e,SETTRK          
 0642 CDE805            call    BIOS            ;set track
 0645 C9        	ret			
                        
                ;***Subroutine********************************
                ; setDrv - Select drive.
                ;*********************************************
                
 0646 3ACF06    setDrv: lda     drvNum
 0649 0600              mvi     b,00h
 064B 4F                mov	c,a		;set drive number in c
 064C 1E1B              mvi     e,SELDSK          
 064E CDE805            call    BIOS            ;set drive
 0651 C9        	ret			
                        
                ;***Subroutine******************************
                ; setNSec - set next sector number
                ;*******************************************
                
 0652 3AD506    setNSec:lda	curSec	        ;last sector accessed
 0655 3C                inr     a               ;move to next sector 
 0656 32D506            sta     curSec          ;new current sector
 0659 C9        	ret 			
                
                ;***Subroutine******************************
                ; setSect - set current sector.
                ;*******************************************
                
 065A 3AD506    setSect:lda	curSec		;current sector
 065D 0600              mvi     b,00h
 065F 4F                mov	c,a		;set sector number in BC
 0660 1E21              mvi     e,SETSEC          
 0662 CDE805            call    BIOS            ;set sector
 0665 C9                ret
                
                ;***Subroutine******************************
                ; setOffs - set offset for current track and 
                ;           sector in buffer.
                ;*******************************************
                
 0666 210014    setOffs:lxi     h,TRKLEN        ;track length
 0669 EB                xchg                    ;track length in DE
 066A 210010            lxi     h,trkBuf        ;buffer start
                
 066D 3AD306            lda     wrtTrk          ;tracks already written
 0670 FE00              cpi     00h
 0672 CA7A06            jz      cmpSOfS         ;compute sector offset in track
                
 0675 19        addTr:  dad     d               ;HL = HL + DE
 0676 3D                dcr     a                       
 0677 C27506            jnz     addTr           ;on zero: HL = BufferStart + written tracks * TRKLEN 
                
                ;translate sector to find correct buffer position
 067A E5        cmpSOfS push    h               ;HL start address of track in buffer
 067B 3AD506            lda	curSec	        ;number of logical sector to write
 067E 21A706            lxi     h,trslate       ;load start of translation table to HL
 0681 1600              mvi     d,00h
 0683 5F                mov     e,a             ;load current logical sector to DE
 0684 19                dad     d               ;add to get address of number of physical sector
 0685 7E                mov     a,m             ;load physical sector number to a
 0686 E1                pop     h
                        
 0687 37                stc
 0688 3F                cmc			;clear carry
 0689 1F        	rar
 068A 57        	mov	d,a		;D=sector >> 1
 068B 1F        	rar			;put lsbit into msbit	
 068C E680      	ani	80h
 068E 5F        	mov	e,a		;DE = 128 * sector
 068F 19                dad     d               ;HL = BufferStart + written tracks * TRKLEN + 128 * sector
 0690 22D106            shld    trkPtr          ;new pointer
 0693 C9        	ret
                
                ;***Subroutine******************************
                ; getEndB - get end of so far written buffer 
                ; and return address in HL
                ;*******************************************
                
 0694 210014    getEndB:lxi     h,TRKLEN        ;track length
 0697 EB                xchg                    ;track length in DE
 0698 210010            lxi     h,trkBuf        ;buffer start
                
 069B 3AD306            lda     wrtTrk          ;tracks already written
 069E FE00              cpi     00h
 06A0 C8                rz      
                        
 06A1 19        addTrB: dad     d               ;HL = HL + DE
 06A2 3D                dcr     a                       
 06A3 C2A106            jnz     addTrB          ;on zero: HL = BufferStart + written tracks * TRKLEN 
 06A6 C9        	ret
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                ; sector translation table
 06A7 00010203  trslate db                       0, 1, 2, 3 
 06AB 14151617          db                      20,21,22,23
 06AF 04050607          db                       4, 5, 6, 7
 06B3 18191A1B          db                      24,25,26,27
 06B7 08090A0B          db                       8, 9,10,11
 06BB 1C1D1E1F          db                      28,29,30,31
 06BF 0C0D0E0F          db                      12,13,14,15
 06C3 20212223          db                      32,33,34,35
 06C7 10111213          db                      16,17,18,19
 06CB 24252627          db                      36,37,38,39
                
                ; disk variables
                
 06CF           drvNum	ds	1		;drive number to use
 06D0           curTrk	ds	1		;current track number drive is on
 06D1           trkPtr	ds	2		;pointer into trkBuf at sector boundaries
 06D3           wrtTrk	ds	1		;count of tracks already written
 06D4           wrtSec	ds	1		;count of sectors already written
 06D5           curSec	ds	1		;current logical sector on track
 06D6           bufEnd	ds	2		;end address + 1 of last track spot in RAM
 06D8           helpVal ds      2               ;dummy value
                        
                ; xmodem variables
                
 06DA           xfrPort	ds	1		;pseudo port for file transfer
 06DB           blkNum	ds	1		;current xmodem block number
 06DC           rcvBlk	ds	1		;block number received
 06DD           rcvNBlk	ds	1		;"not" block number received
 06DE           rcvPtr	ds	2		;pointer for start of XMODEM send
                
                ; misc variables
                
 06E0           biosStart  ds	2		;start of BIOS
 06E2           baseDrv	   ds	1		;ascii 1st drive - baseDrv = 0
 06E3           eotFlag	   ds	1		;set to EOT if EOT terminated reception
 06E4           	   ds	512		;stack space
                
 08E4 =         ourStk	equ	$
 08E4           	ds	PKTLEN		;space for pre-pended unsent data
                	
 1000                   org	1000h		;buffer
 1000 =         trkBuf	equ	$
                
 1000           	end
