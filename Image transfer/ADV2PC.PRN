

                ;*****************************************************************************
                ;  
                ;  Adv2PC - Transfer floppy image from a NortStar Advantage to PC using
                ;           a SIO board in port 1 or 2. 
                ;
                ;
                ;       This program is a Flop2PC-like program. It borrows much of the 
                ;       ideas and the code of these programs written by Mikle Douglas. 
                ;       His Flop2PC programs normally run without an OS but Adv2PC uses 
                ;       CP/M for reading the disk data and the console IO.
                ;
                ;       - copy raw data of double sided doubble density disk in drive A or B
                ;         (512 bytes per sector, 10 sectors per track, 70 tracks). 
                ;         The disk image is the linear sequence of the 512 byte sectors from 
                ;         track 0, sector 0 through track 69, sector 9
                ;       - use SIO board in port 1 or port 2 for the transfer using the XMODEM 
                ;         protocol. 
                ;
                ;	This program only runs under CP/M.
                ;
                ;	Written by Holger Linning
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	01/15/20    Original 
                ;
                ;  based on:
                ;
                ;
                ;  Flop2PC - Transfer floppy image to PC over a serial port using the
                ;	     IMSAI SIO-2 serial board and the North Star single density
                ;	     floppy controller.
                ;
                ;	This program transmits an image of a North Star single density floppy
                ;       to a PC over a serial port using the XMODEM protocol. The disk is
                ;	copied in raw format (256 bytes per sector, 10 sectors per track, 
                ;	35 tracks). The disk image is the linear sequence of the
                ;	256 byte sectors from track 0, sector 0 through track 34,
                ;	sector 9. The leading zeros before the data payload and the checksum
                ;	are not transferred.
                ;
                ;	This program runs standalone at 0x100 or under CP/M.
                ;
                ;	Written by Mike Douglas
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	09/22/19    Original
                ;
                ;*****************************************************************************
                
 FFFF =         TRUE    equ     0ffffh          ;define value of true 
 0000 =         FALSE   equ     NOT TRUE        ;define value of false 
                
                ;*****************************************************************************
                ;
                ;  Switch for running under Advantage emulator ADE or not 
                ;   
                ;     see: North Star Advantage Z80 Computer Emulator (ADE) 
                ;          Jack Strangio
                ;          http://www.itelsoft.com.au/north_star_advantage_emulator.html
                ;
                ;  The emulator can be used for testing and debugging this program. If
                ;  runnuing under ADE set the directive to TRUE.
                ;
                ;*****************************************************************************
                
 0000 =         ADE     equ     FALSE           ;TRUE = ADE, FALSE = real Machine
                
                
                ;*****************************************************************************
                ; Disk information equates
                
 0046 =         NUMTRK	equ	70		;number of tracks
 0028 =         NUMSEC	equ	40		;number of sectors per track (logical CPM sectors)
 0080 =         SECLEN	equ	128		;sector length (logical CPM sectors)
 0000 =         MINDRV	equ	0		;first drive number
 0001 =         MAXDRV	equ	1		;max drive number 
                
 1400 =         TRKLEN	equ	(NUMSEC*SECLEN)	;length of track in bytes
                
                ; CP/M start addresses
 0001 =         BIOSPTR equ     0000h+1         ;pointer to BIOS 
 0006 =         BDOSPTR equ     0005h+1         ;pointer to BDOS         
                
                ; BIOS jump table entry points
 0000 =         BOOT	equ     00h             ;Cold start 
 0003 =         WBOOT	equ     BOOT+3          ;Warm boot
 0006 =         CONST	equ     BOOT+6          ;Console status
 0009 =         CONIN	equ     BOOT+9          ;Console input
 000C =         CONOUT	equ     BOOT+12         ;Console output
 000F =         LIST	equ     BOOT+15         ;Printer output
 0012 =         PUNCH	equ     BOOT+18         ;Paper tape punch output
 0015 =         READER	equ     BOOT+21         ;Paper tape reader input
 0018 =         HOME	equ     BOOT+24         ;Move disc head to track 0
 001B =         SELDSK	equ     BOOT+27         ;Select disc drive
 001E =         SETTRK	equ     BOOT+30         ;Set track number
 0021 =         SETSEC	equ     BOOT+33         ;Set sector number
 0024 =         SETDMA	equ     BOOT+36         ;Set DMA address
 0027 =         READ	equ     BOOT+39         ;Read a sector
 002A =         WRITE	equ     BOOT+42         ;Write a sector
                
                ; XMODEM equates
                        IF      NOT ADE
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
                        ENDIF
                
                        IF      ADE
                DUMMY   equ     0ffh
                SOH	equ	DUMMY           ;use dummy values for XMODEM            
                EOT	equ	DUMMY           
                ACK	equ	DUMMY
                NAK	equ	DUMMY
                        ENDIF
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 000A =         XMTRIES	equ	10		;number of xmodem retries
                
                ; character equates
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7Fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
                
 0100           	org	0100h		;load address
                
                ;-----------------------------------------------------------------------------
                ;   Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 317109    init	lxi	sp,ourStk	;initialize stack pointer
                
 0103 2A0100            lhld    BIOSPTR
 0106 2B                dcx     h
 0107 2B                dcx     h
 0108 2B                dcx     h
 0109 226E07            shld    biosStart       ;save start of BIOS
                
 010C CD9E03    	call	setDrvN		;set drive names 
 010F CDAE03    	call	sizeRam		;determine amount of RAM available
 0112 3E00      	mvi	a,MINDRV	;a=default drive
 0114 325B07    	sta	drvNum		;need for pgmExit
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0117 21DF03    	lxi	h,mWelcom	;display welcome message
 011A CD0E03    	call	dispMsg
                
                ; getDrv - get drive letter from the user.
                
 011D 218504    getDrv	lxi	h,mDrive	;display drive number prompt
 0120 CD0E03    	call	dispMsg
 0123 CD2303    	call	rcvCon		;get byte from the console
 0126 F620      	ori	20h		;upper case letters to lower case
 0128 FE78      	cpi	'x'		;exit requested?
 012A CA7E03    	jz	pgmExit		;yes
 012D 217007    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 0130 96        	sub	m
 0131 FA1D01    	jm	getDrv		;error, entry was < first drive
 0134 FE02      	cpi	MAXDRV-MINDRV+1	;validate <= max drive
 0136 D21D01    	jnc	getDrv		;invalid, prompt again
 0139 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 013B 325B07    	sta	drvNum		;save the drive number to use
                
                ; getPort - get serial port number 1-2 from the user.
                
 013E 21C404    getPort	lxi	h,mPort		;display transfer port prompt
 0141 CD0E03    	call	dispMsg
 0144 CD2303    	call	rcvCon		;get byte from the console
 0147 F620      	ori	20h		;upper to lower case, nums not affected
 0149 FE78      	cpi	'x'		;exit requested?
 014B CA7E03    	jz	pgmExit		;yes
 014E D631      	sui	'1'		;'1' to 0
 0150 FE02      	cpi	2		;validate input was '1' or '2'
 0152 D23E01    	jnc	getPort		;invalid, prompt again
 0155 326607    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to start the XMODEM receive operation on the PC. 
                ;    Wait for a clear receive line for a least one second, then start
                ;    looking for NAK or 'C' (crc protocol) from the PC
                
 0158 211D05    	lxi	h,mStart	;display start file transfer prompt
 015B CD0E03    	call	dispMsg
                
                        IF      ADE
                        jmp     haveNak         ;no need to wait
                        ENDIF
                
 015E CD5A03    clrRcv1	call	rcvByte		;loop until input clear for 1 second
 0161 C25E01    	jnz	clrRcv1         
                
 0164 AF        	xra	a		;set CRC flag to false (checksum mode)
 0165 326907    	sta	crcFlag
 0168 CD6B03    waitNak	call	chkQuit		;give user chance to abort
 016B CD5A03    	call	rcvByte		;wait for a character 
 016E FE15      	cpi	NAK
 0170 CA7B01    	jz	haveNak		;have a NAK, use checksum protocol
 0173 FE43      	cpi	'C'		;CRC protocol requested?
 0175 C26801    	jnz	waitNak		;no
 0178 326907    	sta	crcFlag		;set crc flag non-zero = CRC mode
                
                ;  NAK or 'C' received meaning the XMODEM receive has started. Initialize
                ;     for the transfer.
                
 017B AF        haveNak	xra	a		
 017C 325F07    	sta	sndTrk          ;no tracks sended so far
 017F 325C07    	sta	curTrk          ;start with track 0
 0182 3C        	inr	a		;init xmodem block number to one
 0183 326807    	sta	blkNum
 0186 210010    	lxi	h,trkBuf	;trkBuf is initial starting point for
 0189 226C07    	shld	sndPtr		;   XMODEM send
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Loop through all tracks on the disk buffering as many tracks
                ;    as will fit in RAM before sending via xmodem, then repeat.
                ;-----------------------------------------------------------------------------
 018C CD8806    mainLp	call    initBf          ;init buffering 
 018F 210906            lxi	h,mRead		;display "Reading"	
 0192 CD0E03    	call	dispMsg
                        
                ; Read and buffer tracks 
 0195 CDD901    bufLoop	call	readTrk		;read into trkBuf
                
 0198 3A6007            lda     ctrTrk          ;count new read track
 019B 3C                inr     a
 019C 326007            sta     ctrTrk          
                        
 019F CD9E06            call	setNTrk		;set next track (return in a)
                       
 01A2 FE46      	cpi	NUMTRK		;done all tracks on the disk?
 01A4 CAB401    	jz	sendBuf		;yes, go send the buffered tracks
                        
 01A7 CD1B07    	call	getEndB		;hl=end of used buffer
 01AA EB                xchg			;de=end of used buffer
 01AB 2A6207    	lhld	bufEnd		;hl=end of buffering space
 01AE CDD303    	call	cmpDeHl		;compare current-end
                        
 01B1 DA9501    	jc	bufLoop		;still room, keep going	
                
                ; Track buffer is full or all tracks have been read. Send the buffered
                ;    tracks via xmodem.
                
 01B4 21D305    sendBuf	lxi	h,mSend		;display "Sending"	
 01B7 CD0E03    	call	dispMsg
                       
 01BA CD0002            call	sndTrks		;send the buffered tracks via xmodem
                
 01BD 3A5F07            lda     sndTrk          ;before sended tracks
 01C0 47                mov     b,a
 01C1 3A6007            lda     ctrTrk          ;now sended tracks
 01C4 80                add     b
 01C5 325F07            sta     sndTrk          ;count of all sended tracks
                
 01C8 FE46      	cpi	NUMTRK		;done all tracks?
 01CA C28C01    	jnz	mainLp		;no, not done yet
                
                
                ; Send EOT and wait for response. Then display the success message and
                ;    start the program over.
                
 01CD CDEA02    allDone	call	sndEot		;send and get response for EOT
                
 01D0 215205    	lxi	h,mDone		;print the all done message
 01D3 CD0E03    	call	dispMsg
                
 01D6 C31D01    	jmp	getDrv		;start over asking for a drive
                	
                ;-----------------------------------------------------------------------------
                ; readTrk - read NUMSEC sectors from the current track into a trkBuf as
                ;   pointed to by trkPtr. After the track is read, trkPtr is updated
                ;   by the length of a track to point to the next track buffer.
                ;-----------------------------------------------------------------------------
 01D9 CD9306    readTrk	call    initT           ;init track reading 
 01DC CDB606            call	dSeek		;seek to current track
                
                ; secLoop - Read an entire track. Start at sector 0
                
 01DF CD6B03    secLoop	call	chkQuit		;check for ctrl-c
 01E2 CDDC06            call	setSect		;set desired sector 
 01E5 CDA606    	call	dRead		;read the sector
                
 01E8 CD1B03    	call    dispPgs         ;show progress
                
 01EB CDD406    	call	setNSec		;next sector 
 01EE CDE806            call    setOffs         ;new buffer offset
                        
 01F1 3A6107            lda     curSec          
 01F4 FE28      	cpi	NUMSEC	        ;all sectors read?
 01F6 C2DF01    	jnz	secLoop
                        
 01F9 214A06            lxi	h,mCRLF	        ;new line for next sectors	
 01FC CD0E03    	call	dispMsg
                	
 01FF C9                ret
                
                ;-----------------------------------------------------------------------------
                ; sndTrks - send the tracks buffered in trkBuf via xmodem. trkPtr points
                ;    to the end+1 of the data to send
                ;-----------------------------------------------------------------------------
 0200 CD1B07    sndTrks	call	getEndB		;hl=end of used buffer
 0203 225D07           	shld	trkPtr		;set pointer to end of used buffer
 0206 EB        	xchg			;de=end of buffered data + 1
 0207 2A6C07    	lhld	sndPtr		;hl=start tranmission address
                        
 020A D5        sndLoop	push	d		;save end pointer
 020B CD1B03    	call    dispPgs         ;show progress
 020E CD3C02            call	sndPkt		;send a packet
 0211 D1        	pop	d		;de=end pointer
                
                ; At this point, hl->start of next packet and de->last byte read from disk+1.
                ;    If the next XMODEM packet will go past the end of the disk data,
                ;    we don't want to send it yet.
                
 0212 018000    	lxi	b,PKTLEN	;bc=length of XMODEM packet
 0215 09        	dad	b		;hl=address at end of NEXT packet + 1
 0216 CDD303    	call	cmpDeHl		;compare disk end - end of next packet
 0219 DA2302    	jc	sndDone		;next packet will pass the end, stop
                        
 021C 0180FF    	lxi	b,-PKTLEN	;restore hl
 021F 09        	dad	b
 0220 C30A02    	jmp	sndLoop
                
                ; sndDone - all the packets we can send have been sent. Move any bytes
                ;    left over to just before the start of trkBuf. The next group of
                ;    xmodem packets will be transmitted starting there.
                
 0223 CDD803    sndDone	call	subDeHl		;hl=de-hl = left over byte count - PKTLEN
 0226 7D        	mov	a,l		;a=left over count - PKTLEN
 0227 C680      	adi	PKTLEN		;a=left over byte count
 0229 47        	mov	b,a		;b=count of bytes to move
 022A 210010    	lxi	h,trkBuf	;hl->start of trkBuf
 022D CA3802    	jz	mvDone		;no bytes to move, we're done
                	
                ; Copy the leftover data backwards to just before the track buffer. The
                ;   next XMODEM send sequence will start at the beginning of this copied
                ;   data instead of at the start of trkBuf.
                
 0230 2B        moveLp	dcx	h		;hl->memory just before trkBuf
 0231 1B        	dcx	d		;de->unsent bytes from end of trkBuf
 0232 1A        	ldax	d		;move from end of trkBuf to before trkBuf
 0233 77        	mov	m,a	
 0234 05        	dcr	b
 0235 C23002    	jnz	moveLp
                        
 0238 226C07    mvDone	shld	sndPtr		;save address from which to send next time
 023B C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndPkt - send an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to send. On exit, HL points to the next 128 byte boundary.
                ;-----------------------------------------------------------------------------
 023C 3E0A      sndPkt	mvi	a,XMTRIES	;init retry counter
 023E 326707    	sta	xmRetry
                
                ; First, send header bytes
                
 0241 CD6B03    reSend	call	chkQuit		;check for ctrl-c
 0244 E5        	push	h		;save hl for possible re-send
 0245 3E01      	mvi	a,SOH		;1st byte is SOH
 0247 CD5103    	call	sndByte
 024A 3A6807    	lda	blkNum		;2nd byte is the block number
 024D CD5103    	call	sndByte
 0250 2F        	cma			;2nd complement of block number
 0251 CD5103    	call	sndByte
                
                ; Init checksum and CRC and packet length for transmission of data portion
                
 0254 AF        	xra	a		;init crc
 0255 326A07    	sta	crc16
 0258 326B07    	sta	crc16+1
 025B 110080    	lxi	d,PKTLEN*256	;d=byte counter, e=0 (checksum)
                
                ; Loop sending the data bytes and updating checksum and CRC
                
 025E 7E        pktLoop	mov	a,m
 025F CD5103    	call	sndByte		;send and update checksum in e
 0262 CDCA02    	call	calCrc		;update the CRC
 0265 23        	inx	h		;point to next byte
 0266 15        	dcr	d		;decrement bytes remaining
 0267 C25E02    	jnz	pktLoop
                
                ; Send checksum or CRC based on crcFlag
                
 026A 3A6907    	lda	crcFlag		;crc or checksum?
 026D B7        	ora	a
 026E CA7D02    	jz	sndCsum		;flag clear = checksum
                        
 0271 3A6B07    	lda	crc16+1		;a=high byte of CRC
 0274 CD5103    	call	sndByte		;send it
 0277 3A6A07    	lda	crc16		;a=low byte of crc
 027A C37E02    	jmp	sndSkip		;skip next instruction
                	
 027D 7B        sndCsum	mov	a,e		;send the checksum byte
                
 027E CD5103    sndSkip	call	sndByte
                
                ;  All bytes sent. Wait for the response.
                
 0281 CD5A03    	call	rcvByte		;get the response character
 0284 CA9502    	jz	sndFail		;timeout on response
                        
 0287 FE06      	cpi	ACK		;ack received?
 0289 C29502    	jnz	sndFail		;no, send failed
                        
 028C 3A6807    	lda	blkNum		;increment block number
 028F 3C        	inr	a
 0290 326807    	sta	blkNum
 0293 C1        	pop	b		;remove pushed hl, but don't clobber hl
 0294 C9        	ret
                
                ; sndFail - ACK not received, decrement retry and try again.
                
 0295 216707    sndFail	lxi	h,xmRetry	;point to retry counter
 0298 35        	dcr	m
 0299 CABE02    	jz	xmFail		;retries used up, failed xmodem transfer
                
                ; If we've had 3 NAKs on the 1st packet and CRC is selected, assume
                ;   we took so long to send the 1st packet due to disk retries that
                ;   the receiver has since timed out and switched to checksum
                
 029C 3A6907    	lda	crcFlag		;are we in CRC mode
 029F CAB402    	jz	clrRcv2		;no, ignore the rest of this
                        
 02A2 3A6807    	lda	blkNum		;on block 1?
 02A5 3D        	dcr	a
 02A6 C2B402    	jnz	clrRcv2		;no, go on
                
 02A9 3A6707    	lda	xmRetry		;failed three times in a row on block 1?
 02AC D607      	sui	XMTRIES-3
 02AE C2B402    	jnz	clrRcv2		;no
                
 02B1 326907    	sta	crcFlag		;clear crcFlag to force checksum
                
                ;  clrRcv2 - wait for one second of line clear time and send packet again.
                
 02B4 CD5A03    clrRcv2	call	rcvByte		;wait for 1 second of clear line
 02B7 C2B402    	jnz	clrRcv2
                
 02BA E1        	pop	h		;restore pointer to the packet
 02BB C34102    	jmp	reSend		;re-send the packet
                
                ;  xmFail - Display failure message then restart program
                
 02BE 216A05    xmFail	lxi	h,mXmdm		;xmodem failure message
 02C1 CD0E03    	call	dispMsg
 02C4 317109    	lxi	sp,ourStk	;initialize stack pointer
 02C7 C31D01    	jmp	getDrv		;start over asking for drive
                
                ;-----------------------------------------------------------------------------
                ; calCrc - update the 16-bit CRC with one more byte. 
                ;    (Copied from M. Eberhard)
                ; On Entry:
                ;   a has the new byte
                ;   crc16 is current except this byte
                ; On Exit:
                ;   crc16 has been updated
                ;   Trashes a,bc
                ;-----------------------------------------------------------------------------
 02CA D5        calCrc	push	d
 02CB E5        	push	h
 02CC 2A6A07    	lhld	crc16		;get CRC so far
 02CF AC        	xra	h		;XOR into CRC top byte
 02D0 67        	mov	h,a
 02D1 012110    	lxi	b,1021h		;bc=CRC16 polynomial
 02D4 1608      	mvi	d,8		;prepare to rotate 8 bits
                
                ; do 8 bit shift/divide by CRC polynomial
                
 02D6 29        cRotLp	dad	h		;16-bit shift
 02D7 D2E002    	jnc	cClr		;skip if bit 15 was 0
 02DA 7C        	mov	a,h		;CRC=CRC xor 1021H
 02DB A8        	xra	b
 02DC 67        	mov	h,a
 02DD 7D        	mov	a,l
 02DE A9        	xra	c
 02DF 6F        	mov	l,a
 02E0 15        cClr	dcr	d
 02E1 C2D602    	jnz	cRotLp		;rotate 8 times
                
                ; save the updated CRC and exit
                
 02E4 226A07    	shld	crc16		;save updated CRC
 02E7 E1        	pop	h
 02E8 D1        	pop	d
 02E9 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ;  sndEot - send EOT character and wait for ACK response
                ;-----------------------------------------------------------------------------
 02EA 3E0A      sndEot	mvi	a,XMTRIES	;init retry counter
 02EC 326707    	sta	xmRetry
 02EF 3E04      reEot	mvi	a,EOT		;send the EOT
 02F1 CD5103    	call	sndByte
 02F4 CD5A03    	call	rcvByte		;wait for response
 02F7 CA0003    	jz	eotFail		;timeout
 02FA FE06      	cpi	ACK		;ack received?
 02FC C20003    	jnz	eotFail		;no, eot send failed
 02FF C9        	ret			;otherwise, we're done.
                
                ; timeout waiting for ACK to EOT. Decrement retry counter and try again
                
 0300 216707    eotFail	lxi	h,xmRetry	;point to retry counter
 0303 35        	dcr	m
 0304 C8        	rz			;just give up - xfer was probably good
 0305 CD5A03    clrRcv3	call	rcvByte		;wait for 1 second of clear line
 0308 C20503    	jnz	clrRcv3
 030B C3EF02    	jmp	reEot		;try again
                
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers c, hl
                ;-----------------------------------------------------------------------------
 030E 7E        dispMsg	mov	a,m		;get the next message byte
 030F B7        	ora	a		;null terminates
 0310 C8        	rz
                        
 0311 4F        	mov	c,a		;CONOUT wants character in c
 0312 1E0C              mvi     e,CONOUT
 0314 CD7B06    	call	BIOS
 0317 23        	inx	h		;move to next byte
 0318 C30E03    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; dispPgs - display progress
                ;    Clobbers c
                ;-----------------------------------------------------------------------------
 031B 0E2E      dispPgs	mvi	c,'.'		;CONOUT wants character in c
 031D 1E0C              mvi     e,CONOUT
 031F CD7B06    	call	BIOS
 0322 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers c.
                ;-----------------------------------------------------------------------------
 0323 1E09      rcvCon	mvi     e,CONIN
 0325 CD7B06            call	BIOS		;check for input
                
 0328 E67F      	ani	7fh
 032A FE03      	cpi	CTRLC		;abort requested?
 032C CA7E03    	jz	pgmExit		;yes
                
 032F FE0D      	cpi	CR		;return pressed?
 0331 C8        	rz			;yes, don't echo it
                
 0332 4F        	mov	c,a		;CONOUT needs character in c
 0333 1E0C              mvi     e,CONOUT
 0335 CD7B06    	call	BIOS            ;echo it
                
                ; Wait for CR, then return 1st character typed
 0338 1E09      rcvCr	mvi     e,CONIN
 033A CD7B06            call	BIOS		;check for input
                
 033D E67F      	ani	7fh
 033F FE03      	cpi	CTRLC		;abort requested?
 0341 CA7E03    	jz	pgmExit		;yes
                
 0344 FE7F      	cpi	DEL		;delete
 0346 C8        	rz			;yes, return DEL character
                
 0347 FE08      	cpi	BS		;backspace?
 0349 C8        	rz			;yes, return BS character
 034A FE0D      	cpi	CR		;return pressed?
                
 034C C23803    	jnz	rcvCr		;no, keep waiting
 034F 79        	mov	a,c		;return 1st character typed
 0350 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Adds the byte to register e for checksum. Clobbers b.
                ;     XMODEM send routine assumes serOut returns with a containing
                ;     the character sent.
                ;-----------------------------------------------------------------------------
 0351 47        sndByte	mov	b,a		;b=byte to transmit
 0352 83        	add	e		;update checksum
 0353 5F        	mov	e,a		;e=updated checksum
 0354 3A6607    	lda	xfrPort		;a=port to use for transfer
 0357 C36106    	jmp	serOut		;send the character
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from specified transfer port with a one second
                ;     timeout. If a timeout occurs, zero is returned in a and the zero 
                ;     flag is true. Otherwise, the character is returned in a (could be
                ;     zero) and zero flag is false. ONESEC must be set based on processor
                ;     speed and the number of cycles in the serIn call + 59.
                ;     Clobbers a, b and c.
                ;-----------------------------------------------------------------------------
 035A 01B49A    rcvByte	lxi	b,ONESEC	;bc=cycles through this loop for 1s
                
 035D 3A6607    rcvWait	lda	xfrPort		;(13) a=port to use for transfer
 0360 CD4D06    	call	serIn		;(17+cycles in serIn)look for a byte
 0363 C0        	rnz			;(5)byte received
                
 0364 0B        	dcx	b		;(5)otherwise, decrement timer
 0365 78        	mov	a,b		;(5)one second expire?
 0366 B1        	ora	c		;(4)
 0367 C25D03    	jnz	rcvWait		;(10)no, keep waiting
 036A C9        	ret			;return with timeout (zero true and in a)
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 036B 1E06      chkQuit	mvi     e,CONST
 036D CD7B06            call	BIOS		;check for console input
 0370 FE00              cpi     00h             ;0 = no character
 0372 C8        	rz
                        
 0373 E67F      	ani	7fh
 0375 FE03      	cpi	CTRLC		;abort requested?
 0377 C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 0378 317109    	lxi	sp,ourStk	;initialize stack pointer
 037B C31D01    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M 
                ;--------------------------------------------------------------
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 037E 3A5B07    pgmExit	lda	drvNum		;boot drive used?
 0381 D600      	sui	MINDRV
 0383 C28F03    	jnz	noDisk		;not 1, disk prompt not needed
                        
 0386 219C05    	lxi	h,mCpm		;display "insert cp/m disk"	
 0389 CD0E03    	call	dispMsg
 038C CD2303    	call	rcvCon		;wait for a character
                        
 038F 218C05    noDisk	lxi	h,mExit		;display "exiting" message
 0392 CD0E03    	call	dispMsg
                        
 0395 2A6E07            lhld    biosStart
 0398 1600              mvi     d,00h
 039A 1E03              mvi     e,WBOOT
 039C 19                dad     d
 039D E9        	pchl		        ;reboot CP/M
                
                ;--------------------------------------------------------------
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                ;--------------------------------------------------------------
                
 039E 3E41      setDrvN	mvi	a,'A'		;'A' in drive message instead of number
 03A0 32B004    	sta	mDrvMin
 03A3 C601      	adi	MAXDRV-MINDRV	;max drive letter
 03A5 32B204    	sta	mDrvMax
 03A8 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 03AA 327007    	sta	baseDrv
 03AD C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
 03AE 2A0600    sizeRam	lhld	BDOSPTR		;get address of BDOS
                
                ; ramEnd - end of RAM found. Now determine the end address + 1 of the
                ;   last track buffer that will fit in RAM. Store in bufEnd
                
 03B1 EB        ramEnd	xchg			;de=end of RAM + 1
 03B2 3EEB      	mvi	a,-((TRKLEN SHR 8) + 1) AND 0ffh
 03B4 BA        	cmp	d		;force de < (10000h - TRKLEN)
 03B5 D2B903    	jnc	topOk
 03B8 57        	mov	d,a		;limit max address
 03B9 210010    topOk	lxi	h,trkBuf	;hl=start of track buffer
 03BC 010014    	lxi	b,TRKLEN	;bc=length of track in bytes
                
                ; Loop increasing hl by TRKLEN until hl > end of RAM.
                
 03BF 09        bfEndLp	dad	b		;hl=hl+track length
 03C0 CDCE03    	call	cmpHlDe		;compare hl-de
 03C3 DABF03    	jc	bfEndLp		;still more room, keep going
                
                ; Subtrack one track length from hl, this will be the end address + 1 of
                ;   the the last track buffer that will fit in RAM
                
 03C6 0100EC    	lxi	b,-TRKLEN	;subtract one track length
 03C9 09        	dad	b		;hl = end address of last track + 1
 03CA 226207    	shld	bufEnd		;save as bufEnd
 03CD C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 03CE 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 03CF 93        	sub	e
 03D0 7C        	mov	a,h		;do msbs
 03D1 9A        	sbb	d
 03D2 C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 03D3 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 03D4 95        	sub	l
 03D5 7A        	mov	a,d		;do msbs
 03D6 9C        	sbb	h
 03D7 C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subDeHl - HL=DE-HL
                ;--------------------------------------------------------------------
 03D8 7B        subDeHl	mov	a,e		;subtract DE-HL, do lsbs first
 03D9 95        	sub	l
 03DA 6F        	mov	l,a		;lsb result in l
 03DB 7A        	mov	a,d		;do msbs
 03DC 9C        	sbb	h
 03DD 67        	mov	h,a		;msb result in h	
 03DE C9        	ret
                
                ;---------------------------------------------------------------------
                ; Message constants
                ;---------------------------------------------------------------------
 03DF 0D0A0A    mWelcom	db	cr,lf,lf
 03E2 3D3D3D3D3D	db	'===== Northstar Advantage to PC Image Transfer, v1.0 ====='
 041C 0D0A0A    	db	cr,lf,lf
 041F 5468697320	db	'This program transfers an image of a Northstar Advantage'
 0457 0D0A      	db	cr,lf
 0459 746F206120	db	'to a PC through a serial port using XMODEM.',0
                
 0485 0D0A0A496EmDrive	db	cr,lf,lf,'Insert floppy and specify source drive ('
 04B0 782D      mDrvMin	db	'x-'
 04B2 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 04C4 0D0A0A    mPort	db	cr,lf,lf
 04C7 5370656369	db	'Specify the port of the SIO card to use for the image ',cr,lf
 04FF 7472616E73	db	'transfer (1-2) or X to exit: ',0
                
 051D 0D0A0A5374mStart	db	cr,lf,lf,'Start XMODEM receive operation on the PC now...',cr,lf,0
                
 0552 0D0A0A5472mDone	db	cr,lf,lf,'Transfer complete!',cr,lf,0
                
 056A 0D0A0A584DmXmdm	db	cr,lf,lf,'XMODEM communication failure',cr,lf,0
                
 058C 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 059C 0D0A0A    mCpm	db	cr,lf,lf
 059F 496E736572	db	'Insert CP/M disk into drive A, then press RETURN...',0
                
 05D3 0D0A0A    mSend	db	cr,lf,lf
 05D6 53656E6469	db	'Sending buffer data to PC (dot = XMODEM packet)',cr,lf,lf,0
                
 0609 0D0A0A    mRead	db	cr,lf,lf
 060C 5265616469	db	'Reading floppy data to buffer (line = track, dot = sector)',cr,lf,lf,0
                
 064A 0D0A00    mCRLF	db	cr,lf, 0
                
                ;****************************************************************************
                ;
                ;  Hardware specific serial I/O routines. 
                ;     The following routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; 8251 UART Equates
                
 0051 =         SIOACR	equ	51h		;control, SIO Board in slot 1
 0050 =         SIOADR	equ	50h		;data, SIO Board in slot 1
                
 0041 =         SIOBCR	equ	41h		;control, SIO Board in slot 2
 0040 =         SIOBDR	equ	40h		;data, SIO Board in slot 2
                
 0002 =         SIORDA	equ	02h		;read data available flag
 0001 =         SIOTRE	equ	01h		;transmit register empty flag
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 9AB4 =         ONESEC	equ	39604		;rcvByte loop count for 1 second (4mhz)
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = first serial port
                ;       1 = second serial port
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ; 42 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 064D B7        serIn	ora	a		;(4) port 0 or 1?
 064E C25906    	jnz	s2InB		;(10) port 1, 2nd serial port
                
                ; Input from 1st serial port
                
 0651 DB51      s2InA	in	SIOACR		;(10+1) see if a new character is present
                        
                        IF      ADE
                        mvi     a,SIORDA        ;character always available if ADE
                        ENDIF
                	
 0653 E602              ani	SIORDA		;(7)
 0655 C8        	rz			;(10) no character, return zero status
 0656 DB50      	in	SIOADR		;return character and non-zero status
                
                        IF      ADE
                        mvi     a,DUMMY         ;use just dummy character 
                        ENDIF
                
 0658 C9        	ret	
                	
                ; Input from 2nd serial port
                
 0659 DB41      s2InB	in	SIOBCR		;(10+1) see if a new character is present
                        
                        IF      ADE
                        mvi     a,SIORDA        ;character always available if ADE
                        ENDIF
                	
 065B E602      	ani	SIORDA		;(7)
 065D C8        	rz			;(10) no character, return zero status
 065E DB40      	in	SIOBDR		;return character and non-zero status
                
                        IF      ADE
                        mvi     a,DUMMY         ;use just dummy character 
                        ENDIF
                
 0660 C9        	ret		
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = console serial port
                ;       1 = second serial port
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;-----------------------------------------------------------------------------
 0661 B7        serOut	ora	a		;port 0 or 1 ?
 0662 C27006    	jnz	s2OutB		;second serial port
                
                ; Send character through console serial port
                
 0665 DB51      S2OutA	in	SIOACR		;wait for OK to transmit
 0667 E601      	ani	SIOTRE
 0669 CA6506    	jz	S2OutA
 066C 78        	mov	a,b		;a=character to transmit
 066D D350      	out	SIOADR		;send it
 066F C9        	ret
                
                ; Send character through second serial port
                
 0670 DB41      s2OutB	in	SIOBCR		;wait for OK to transmit
 0672 E601      	ani	SIOTRE
 0674 CA7006    	jz	s2OutB
 0677 78        	mov	a,b		;a=character to transmit
 0678 D340      	out	SIOBDR		;send it
 067A C9        	ret
                
                ;****************************************************************************
                ;
                ; BIOS related routines
                ;
                ;****************************************************************************
                
                ;***Subroutine**************************************
                ;
                ; BIOS -  perform the BIOS calls based on parameter 
                ; in register E to make calls independent of memory 
                ; layout (CP/M Vers. 2.2 Rev A / CP/M Vers. 2.2 Rev 1.2.0) 
                ;
                ; input parameters for BIOS calls in A, C or BC
                ; output parameters for BIOS calls in A
                ; offset of BIOS function in E
                ; preserves HL
                ;
                ;***************************************************
                
 067B E5        BIOS    push    h               ;save HL
 067C CD8106            call    jmpBIOS         ;call BIOS function
 067F E1                pop     h               ;restore HL
 0680 C9                ret
                
 0681 2A6E07    jmpBIOS lhld    biosStart       ;start of BIOS in HL
 0684 1600              mvi     d,00h
 0686 19                dad     d               ;offset for BIOS call in E
 0687 E9                pchl                    ;jump to BIOS routine
                
                ;***Subroutine**************************************
                ; initBf - init vars for buffer 
                ;***************************************************
                
 0688 210010    initBf: lxi     h,trkBuf        ;buffer start
 068B 225D07            shld    trkPtr          ;reset pointer
 068E AF                xra	a
 068F 326007            sta     ctrTrk          ;init count of tracks
                                                ;in buffer
 0692 C9                ret
                
                ;***Subroutine**************************************
                ; initT - init vars for reading track 
                ;***************************************************
                
 0693 AF        initT:  xra	a
 0694 326107            sta     curSec          ;start at sector 0
 0697 CD1B07            call    getEndB         ;get start of buffer in HL
 069A 225D07            shld    trkPtr          ;pointer to free buffer
 069D C9                ret
                
                ;***Subroutine******************************
                ; setNTrk - set next track number
                ;*******************************************
                
 069E 3A5C07    setNTrk:lda	curTrk	        ;current track accessed
 06A1 3C                inr     a               ;move to next track 
 06A2 325C07            sta     curTrk          ;new current track
 06A5 C9        	ret 			
                
                ;***Subroutine**************************************
                ; dRead - Read sector on current track to buffer at prt.
                ;***************************************************
                
 06A6 2A5D07    dRead:	lhld    trkPtr          ;pointer in buffer
 06A9 44                mov	b,h		;set dma address in BC
 06AA 4D                mov	c,l		
 06AB 1E24              mvi     e,SETDMA
 06AD CD7B06            call    BIOS            ;set dma address 
 06B0 1E27              mvi     e,READ          
 06B2 CD7B06            call    BIOS            ;read track
 06B5 C9        	ret			
                        
                ;***Subroutine**************************************
                ; dSeek - set drive and track
                ;***************************************************
                
 06B6 CDC506    dSeek:	call	setDrv		;select drive
 06B9 3A5C07    	lda	curTrk		;load track number
 06BC 0600              mvi	b,00h		;set track number in BC
 06BE 4F                mov	c,a		
 06BF 1E1E              mvi     e,SETTRK          
 06C1 CD7B06            call    BIOS            ;set track
 06C4 C9        	ret			
                        
                ;***Subroutine********************************
                ; setDrv - Select drive.
                ;*********************************************
                
 06C5 3A5B07    setDrv: lda     drvNum
 06C8 0600              mvi     b,00h
 06CA 4F                mov	c,a		;set drive number in c
 06CB 1E1B              mvi     e,SELDSK          
 06CD CD7B06            call    BIOS            ;set drive
 06D0 226407            shld    ptrDPH;         ;save disk parameters
 06D3 C9        	ret			
                        
                ;***Subroutine******************************
                ; setNSec - set next sector number
                ;*******************************************
                
 06D4 3A6107    setNSec:lda	curSec	        ;last sector accessed
 06D7 3C                inr     a               ;move to next sector 
 06D8 326107            sta     curSec          ;new current sector
 06DB C9        	ret 			
                
                ;***Subroutine******************************
                ; setSect - set current sector.
                ;*******************************************
                
 06DC 3A6107    setSect:lda	curSec		;current sector
 06DF 0600              mvi     b,00h
 06E1 4F                mov	c,a		;set sector number in BC
 06E2 1E21              mvi     e,SETSEC          
 06E4 CD7B06            call    BIOS            ;set sector
 06E7 C9                ret
                
                ;***Subroutine******************************
                ; setOffs - set offset for current track and 
                ;           sector in buffer.
                ;*******************************************
 06E8 210014    setOffs:lxi     h,TRKLEN        ;track length
 06EB EB                xchg                    ;track length in DE
 06EC 210010            lxi     h,trkBuf        ;buffer start
                
 06EF 3A5F07            lda     sndTrk          ;tracks sended
 06F2 47                mov     b,a
 06F3 3A5C07            lda     curTrk          ;current track
 06F6 90                sub     b               ;don't count tracks that were already sended
 06F7 FE00              cpi     00h             ;    = (current track - sended tracks)
 06F9 CA0107            jz      cmpSOfS         ;compute sector offset in track
                
 06FC 19        addTr:  dad     d               ;HL = HL + DE
 06FD 3D                dcr     a                       
 06FE C2FC06            jnz     addTr           ;on zero: HL = BufferStart + 
                                                ;   tracks in buffer * TRKLEN 
                
                ;translate sector to find correct buffer position
 0701 E5        cmpSOfS push    h               ;HL start address of track in buffer
 0702 3A6107            lda	curSec	        ;number of logical sector to read
 0705 213307            lxi     h,trslate       ;load start of translation table to HL
 0708 1600              mvi     d,00h
 070A 5F                mov     e,a             ;load current logical sector to DE
 070B 19                dad     d               ;add to get address of number of physical sector
 070C 7E                mov     a,m             ;load physical sector number to a
 070D E1                pop     h
                        
 070E 37                stc
 070F 3F                cmc			;clear carry
 0710 1F        	rar
 0711 57        	mov	d,a		;D=sector >> 1
 0712 1F        	rar			;put lsbit into msbit	
 0713 E680      	ani	80h
 0715 5F        	mov	e,a		;DE = 128 * sector
 0716 19                dad     d               ;HL = BufferStart + numTrk * TRKLEN + 128 * sector
 0717 225D07            shld    trkPtr          ;new pointer
 071A C9        	ret
                
                ;***Subroutine******************************
                ; getEndB - get end of so far used buffer 
                ; and return address in HL
                ;*******************************************
 071B 210014    getEndB:lxi     h,TRKLEN        ;track length
 071E EB                xchg                    ;track length in DE
 071F 210010            lxi     h,trkBuf        ;buffer start
                
 0722 3A5F07            lda     sndTrk          ;tracks already sended
 0725 47                mov     b,a
 0726 3A5C07            lda     curTrk          ;current track
 0729 90                sub     b               ;don't count track that were already sended
 072A FE00              cpi     00h
 072C C8                rz      
                        
 072D 19        addTrB: dad     d               ;HL = HL + DE
 072E 3D                dcr     a                       
 072F C22D07            jnz     addTrB          ;on zero: HL = BufferStart + numTrk * TRKLEN 
 0732 C9        	ret
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                
                ; sector translation table
 0733 00010203  trslate db                       0, 1, 2, 3 
 0737 14151617          db                      20,21,22,23
 073B 04050607          db                       4, 5, 6, 7
 073F 18191A1B          db                      24,25,26,27
 0743 08090A0B          db                       8, 9,10,11
 0747 1C1D1E1F          db                      28,29,30,31
 074B 0C0D0E0F          db                      12,13,14,15
 074F 20212223          db                      32,33,34,35
 0753 10111213          db                      16,17,18,19
 0757 24252627          db                      36,37,38,39
                
                ; disk variables
                
 075B           drvNum	ds	1		;drive number to use
 075C           curTrk	ds	1		;current track number drive is on
 075D           trkPtr	ds	2		;pointer into trkBuf at sector boundaries
 075F           sndTrk	ds	1		;count of tracks already sended
 0760           ctrTrk  ds      1               ;count tracks 
 0761           curSec	ds	1		;current logical sector on track
 0762           bufEnd	ds	2		;end address + 1 of last track spot in RAM
 0764           ptrDPH  ds      2               ;address of disk parameter header returned by SELDSK
                
                ; xmodem variables
                
 0766           xfrPort	ds	1		;pseudo port for file transfer
 0767           xmRetry	ds	1		;xmodem retry counter
 0768           blkNum	ds	1		;current xmodem block number
 0769           crcFlag	ds	1		;non zero if using CRC instead of checksum
 076A           crc16	ds	2		;crc-16 result
 076C           sndPtr	ds	2		;pointer for start of XMODEM send
                
                ; misc variables
                
 076E           biosStart  ds	2		;start of BIOS
 0770           baseDrv	   ds	1		;ascii 1st drive - baseDrv = 0
 0771           	   ds	512		;stack space
                
 0971 =         ourStk	equ	$
 0971           	ds	PKTLEN		;space for pre-pended unsent data
                	
 1000                   org	1000h		;buffer
 1000 =         trkBuf	equ	$
                
 1000           	end
